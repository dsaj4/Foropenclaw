#!/usr/bin/env python3
import argparse
import base64
import json
import pathlib
import urllib.error
import urllib.parse
import urllib.request


def _auth_header(user: str, password: str) -> str:
    token = base64.b64encode(f"{user}:{password}".encode("utf-8")).decode("ascii")
    return f"Basic {token}"


def _request(url: str, user: str, password: str, method: str = "GET", payload=None):
    headers = {"Authorization": _auth_header(user, password), "Content-Type": "application/json"}
    data = None
    if payload is not None:
        data = json.dumps(payload, ensure_ascii=False).encode("utf-8")
    req = urllib.request.Request(url=url, method=method, headers=headers, data=data)
    try:
        with urllib.request.urlopen(req) as res:
            raw = res.read().decode("utf-8")
            return json.loads(raw) if raw else {}
    except urllib.error.HTTPError as e:
        body = e.read().decode("utf-8", errors="replace")
        raise RuntimeError(f"HTTP {e.code} {e.reason}: {body}") from e


def _request_allow_404(url: str, user: str, password: str):
    try:
        return _request(url, user, password, "GET"), 200
    except RuntimeError as e:
        if "HTTP 404" in str(e):
            return None, 404
        raise


def _doc_url(base: str, db: str, doc_id: str):
    return f"{base.rstrip('/')}/{urllib.parse.quote(db, safe='')}/{urllib.parse.quote(doc_id, safe='')}"


def rollback(manifest_path: pathlib.Path, url: str, user: str, password: str):
    manifest = json.loads(manifest_path.read_text(encoding="utf-8"))
    db = manifest["target_db"]
    doc_id = manifest["target_id"]
    pre_doc_file = pathlib.Path(manifest["pre_doc_file"])

    if not pre_doc_file.exists():
        raise RuntimeError(f"pre_doc_file not found: {pre_doc_file}")

    previous_doc = json.loads(pre_doc_file.read_text(encoding="utf-8"))
    current_doc, current_status = _request_allow_404(_doc_url(url, db, doc_id), user, password)

    previous_deleted = bool(previous_doc.get("_deleted", False))

    if previous_deleted:
        if current_status == 404:
            return {"ok": True, "action": "noop", "reason": "doc already absent"}
        target = _doc_url(url, db, doc_id) + f"?rev={urllib.parse.quote(current_doc['_rev'], safe='')}"
        out = _request(target, user, password, "DELETE")
        return {"ok": True, "action": "delete", "result": out}

    restore_doc = dict(previous_doc)
    if current_status == 200:
        restore_doc["_rev"] = current_doc["_rev"]
    else:
        restore_doc.pop("_rev", None)

    out = _request(_doc_url(url, db, doc_id), user, password, "PUT", restore_doc)
    return {"ok": True, "action": "put", "result": out}


def main():
    p = argparse.ArgumentParser(description="Rollback one safe_change operation by manifest.")
    p.add_argument("--manifest", required=True, help="Path to manifest.json generated by safe_change.sh")
    p.add_argument("--url", required=True, help="CouchDB base URL")
    p.add_argument("--user", required=True)
    p.add_argument("--password", required=True)
    args = p.parse_args()

    result = rollback(pathlib.Path(args.manifest), args.url, args.user, args.password)
    print(json.dumps(result, ensure_ascii=False, indent=2))


if __name__ == "__main__":
    main()
